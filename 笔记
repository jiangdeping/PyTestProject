__init__.py or __all__=[]  #指对外开放有哪些内容,  调用方式必须 from * import * 方式导入
python 3.3版本 以后不需要__init__.py 文件也可以直接调用
浮点数精度问题：Decimal("0.1")+Decimal("0.2")
导出依赖包：
pip install -r requirements.txt
pip free >requirements.txt
----------------pytest------------
<<<<<<< HEAD
相关包安装：
pip install  pytest                ---pytest框架
pip install  allure-pytest         ---生成allure报告
pip install  pytest-assume         ---断言失败不会停止
pip install  pymysql               ---mysql数据库连接
pip install  pytest-rerunfailures  ---失败重跑
pip install   xlrd                 ---读取excel文件
pip install pytest-xdist           ---并行与分布式执行
pip install pytest-html            ---测试报告
pip install PyYAML                 ---yaml安装
pip install allure-pytest          ---测试allure-pytest插件
pip install pytest-ordering        ---测试用例顺序执行
=======
>>>>>>> parent of e736816 (2021/8/25:fix)
终端执行
pytest -v -s  文件名.py （-v 打印详细运行日志信息  -s带控制台输出结果）
pytest 文件名.py::类名 运行摸个模块里面的某个类
pytest 文件名.py::类名::方法名 运行某个模块里面的某个类里面的方法
pytest -m[标记名] @python.mark.[标记名] 将运行有这个标记的测试用例
pytest -x 文件名 运行到报错就停止
pytest --maxfail=[num] 当运行错误达到num的时候停止运行

pytest运行规则：
pytest 收集所有以 test_*.py(可在pytest.ini修改)开头的文件，类及函数和方法，都能识别成测试用例
常用参数
-k:满足表达式的都会执行
--collect-only 收集所有测试用例 不执行
-m 加标签，执行需要加个 -m参数，为用例@pytest.mark 标签名
-junit-xml 生产一个执行结果的xml文件

conftest.py文件:将需要共享的公共模块放在该文件，该文件放在不同的位置起着不同的范围共享作用，
不需要导入该文件，系统执行到参数时首先先从本文件中查找，然后在conftest.py中查找
改写一些方法，改写执行顺序
改写方法，自动添加标签
配置注意事项：
conftest.py文件名是不能更换的，与运行的用例放在同一package下

pytest.ini 配置文件
改变pytest运行的行为
“”“
[pytest]
addopts=--alluredir=./result/1
python_files="abc_*py"
python_classes="Login*"
python_functions="case*"
“”“

pytest失败重新运行：
pip install pytest-rerunfailures
pytest --reruns 3  --reruns-delay 2  -v -s 文件名.py  #--reruns 3 重新执行的次数 --reruns-delay 2 等待2s执行


断言：assert
通常一个用例我们会写多个断言，有时候我们希望第一个断言失败后，后面能继续断言，pytest-assume插件可以解决断言失败后继续断言的问题
pip install pytest-assume
pytest.assume(x == y)

pycharm 配置与执行pytest测试框架
pytest.main("-v -x TestDemo") 、pytest.main(['-v','-s','TestDemo'])等同

pytest框架结构:
pytest的setup、teardown更灵活，执行顺序：
模块级(setup_module/teardown_module)模块始末，全局的(优先更高)
函数级(setup_function/teardown_function)只对函数用例生效(不在类中)
类级(setup_class/teardown_class)只在类中前后运行一次(在类中)
方法级(setup_method/teardown_method)开始于方法始末(在类中)
类里面的(setup/teardown)运行在调用方法的前后

pytest-fixture:
有些用例需要登录，有些不需要登录。setup和teardown无法满足，fixture可以
在登录的函数面前加入@pytest.fixture,在需要登录的测试方法中传入登录函数名称

yield 生成器， 相当于:return i+暂停+并记住上一次运行位置,与fixture结合使用，激活yield后面的操作
yield：通过在方法中加入yield关键字，yield之前的第一次调用该方法时执行，yield之前的后在最后一次调用该方法时执行
@pytest.fixture(scope=module)
scope:session 作用域、function 方法 、class 类 、module 模块、package包
执行顺序：session>module>function,如果有antouse=True,优先于同等级


fixture的自动化应用：
在方法上加 @pytest.fixture(autouse=True)，每一条测试用例都加上该方法
在测试方法上加 @pytest.mark.usefixtures("start")

fixture带参数传递
@pytest.fixture(params=[1,2,3,'linda']),在方法参数前写request



mark中的skip与xfail
skip：不想运行某些测试用例，skipif 满足条件的不运行该用例
xfail：标记用例预期失败，如果用例运行成功则显示Xpassed，失败则显示xfailed。
xfail标记并不会影响用例的运行。设置strict=True以确保XPASS时，测试的记录为失败

pytest并行与分布式执行：
pytest  文件名.py -n number

pytest-html:生成报告
pytest -v -s --html=report.html--self-contained-html

pytest数据参数化
@pytest.mark.parametrize(argnames,argvalues)  argnames,argvalues一一对应
argnames:要参数化的变量,string,list,tuple
argvalues:参数化的值,list,list[tuple]

yaml实现list
pip install PyYAML
yaml.safe_load(open("文件名.yaml"))

数据驱动：app、web、接口自动化测试
测试步骤的数据驱动、测试数据的数据驱动、配置的数据驱动

allure:
安装：
1.安装jdk1.8+(百度网盘)
2.安装Allure(百度网盘)
  解压并进入bin目录，运行allure.bat，将bin路径添加allure到环境变量PATH
3.安装allure—pytest插件
步骤：
1.测试执行期间收集执行结果
pytest 文件名.py  --alluredir=./result/1 (--alluredir 指定存储测试结果的路径)
2.生成测试报告
 方法1：测试完成后查看实际报告 allure serve ./result/5
 方法2：从结果生成报告
      生成报告：allure generate ./result/ -O ./report --clean(覆盖路径加--clean)
      查看报告：allure open -h 127.0.0.1 -p 8883 ./report/

常用特性
@allure.feature("功能名称")
@allure.story("子功能名称")
with.allure.step("步骤细节")
@allure.attach("具体文本信息"，需要附近的信息可以是数据、文本、图片、视频、网页)
只运行部分功能：pytest 文件名  --allure_features "功能名称"  --allure_stories "子功能名称"

按重要级别进行的范围测试
1.附加pytest.mark标记
2.allure.feature,allure.story
3.allure.severity附加标记   级别：Trivial不重要、Minor不太重要、Normal正常、Critical严重、Blocker阻塞
步骤：
在方法、函数和类前面加：@allure.severity(allure.severity_level.级别)
执行时：pytest -s -v 文件名 --allure-severities 级别(可多个用’,‘分割)

驱动:
测试数据的驱动
测试步骤的驱动



---------------selenium----------------
chromedriver下载地址：http://npm.taobao.org/mirrors/chromedriver
webdriver
IDE：录制
Grid：分布式

隐示等待：implicitly_wait   #放入setup方法中
显示等待：WebDriverWait(self.driver,10).until(expected_conditions.element_to_be_clickable(())) #查找元素使用


xpath：xml路径语言，用于xml的节点定位
XPATH:Path Language(速度比较慢)
/从根节点选取   //从匹配选择的当前节点选择文档中的节点，不考虑他们的位置
. 选择当前节点   ..选择当前节点的父节点  @选取属性
/bookstore/book[1]      选取属于bookstore子元素的第一个book元素
/bookstore/book[last()]  选取属于bookstore子元素的最后一个book元素
/bookstore/book[last()-1] 选取属于bookstore子元素的倒数第二book元素
/bookstore/book[position()<3]  选取最前面的2个属于bookstore元素的子元素的book元素
//title[@lang]  选取所有拥有名为lang属性的title元素
//title[@lang="eng"]  选取所有title元素，这些元素拥有值为eng的lang属性
/bookstore/book[price>10] 选取bookstore的所有book元素，且price>10
/bookstore/book[price>10]/title 选取bookstore的所有book元素的所有title元素，且price>10
选取未知节点：
* 匹配任何元素节点
@*匹配任何属性节点
node[]匹配任何类型的节点
/bookstore/* 选取bookstore元素的子元素
//*选取文档中的所有元素
//title[@*]选取所有带有属性title的元素


CSS Selector定位:
浏览器操作：$('#su')
# 表示id
. 表示class
> 表示子元素，层级


ActionChains：执行PC端的鼠标点击、双击、右键、拖拽等事件
TouchActions：模拟PC和移动端的点击、滑动、拖拽、多点触控等多种手势操作
当用户调用ActionChains方法执行动作时，这些动作会被存储到一个ActionChains对象的队列中，此时并不会真
正执行这些动作。而当调用perform()时，ActionChains对象中动作队列会被一一执行
action.drag_and_drop(drag_element,drop_element).perform() #拖拽方法1
action.click_and_hold(drag_element).release(drop_element).perform()#拖拽方法2


selenium 如何处理多窗口：
点击某些链接，会重新打开一个窗口，对于这种情况，想在新页面操作就需要切换窗口了
获取窗口唯一标识用句柄表示，所以只需要切换句柄，就可以在多个页面灵活操作
获取当前窗口的句柄：driver.current_window_handle
获取到所有的窗口句柄：driver.window_handles
切换窗口：switch_to_window

frame：一个元素定位不到，很大可能该元素不再iframe中
frame分类：frameset、frame、iframe
driver.switch_to.frame()：根据元素ID或index切换frame
driver.switch_to.default_content() 切换到默认frame
driver.switch_to.parent_frame 切换到父级frame
对于签到的iframe：先切换到父节点在切换到子节点

selenium执行javascript脚本，解决:
1.直接使用JS操作页面，解决很多click()不生效的问题
2.页面滚动到底部，顶部
3.处理富文本，时间控件输入等
execute_script：执行js
return:返回js的返回结果
execute_script：arguments传参
JS处理时间控件思路：
1.取消日期的readonly属性 :
a=document.getElementById("train_date")
a.removeAttribute('readonly')
2.给value赋值
3.写js代码实现如上2点，在用webdriver对js进行处理

selenium文件上传：input标签可以直接使用send_keys(文件地址)上传文件

弹框处理机制：
在页面操作中会遇到JavaScript生产的alert、confirm及prompt弹框，可以使用switch_to.alert()方法定位。
然后使用text/accept/dismiss/send_keys等方法进行操作
操作alert常用方法：
switch_to.alert():获取当前页面的警告框
text:返回alert、confirm及prompt中的文字信息
accept():接受现有警告框
dismiss():解散现有警告框
send_keys(keysToSend):发送文件警告框。keysToSend：将文本发送至警告框
#snipaste  截图工具

page Objects 六大原则：
1.公共方法表示页面提供的服务
2.不要暴露页面的细节
3.Page设计中不要出现断言，应该写在测试用例类中
4.方法应该返回其他的Page对象
5.不要去代表整个page，如果一个页面中有很多功能，只需要对重点功能封装方法即可
6.不同的结果返回不同的方法，不同的模式

selenium复用浏览器
1.chrome浏览器放入环境变量
2.在命令下执行:chrome --remote-debugging-port=9222
3.options=Options()
  options.debugger_address="127.0.0.1:9222"
  driver=webdriver.Chrome(options=options)


元素的常用方法  （appium selenium均可用）
是否可见 is_displayed()
是否可用 is_enalberd()
是否被选择 is_selected()
获取属性 get_attribute()
清除 clear
设置元素值 ser_value()
元素常用的属性： （appium selenium均可用）
元素文本 text
元素坐标 locationg
元素尺寸 size
------------------appium-----------------
appnium设计原理
客户端：python3,appnium-python-client
服务端：
方法一：appium-desktop：appium inspector 录制功能和appium server
方法二：appium server
 node js>=10,建议12.*版本，npm>=6
 npm install -g cnpm --registry==https://registry.npm.taobao.org
 cnpm install -g appium
3.手机端（被测设备）：
 Android 设备，可以在运行在window、MacOS、Linux环境
 ios 设备：必须在MacOS系统
 模拟器

appium安装环境搭建：https://www.cnblogs.com/fnng/p/4540731.htmlhttps://www.cnblogs.com/fnng/p/4540731.html
1.JDK 1.8及以上版本安装
2.SDK安装及环境变量配置 ：http://tools.android-studio.org/index.php/sdk
   ANDROID_HOME D:\android-sdk-windows
   PATH  %ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools
   查看安装成功  adb
3.appium环境安装及客户端安装：
  方法一：下载安装包安装：https://github.com/appium/appium-desktop/releases
  方法二：npm安装:   需要先装 node.js   node js>=10,建议12.*版本，npm>=6
     npm install -g cnpm --registry==https://registry.npm.taobao.org
     cnpm install -g appium
4.安装appnium-client：pip install appium-python-client
5.安装appium-doctor:npm install appium-doctor  查看appium安装信息
6.安装网易mumu模拟器：https://mumu.163.com/
 无法连接网易mumu：D:\MuMu\emulator\nemu\vmonitor\bin下执行：adb connect 127.0.0.1:7555
 使用教程：https://www.pianshen.com/article/27411242829/
 真机：1.打开调试模式 2.安装驱动程序（如豌豆荚）


adb命令安装应用：https://developer.android.google.cn/studio/command-line/adb
 adb install 名称.apk  -r 覆盖安装 -s 选择安装设备
adb组件：adb client、adb server、adbd
adb client：用户发送命令。在开发计算机上运行，通过发送adb命令从命令行终端调用客户端
adb server：管理客户端与守护进程之间的通信。服务器在开发机器上作为后台进程运行
adbd(守护进程)：在设备上运行命令，在每个设备上作为后台进程运行
appium -p 端口号：命令启用appium服务
 常用端口分析：
 4723：appium提供的默认端口号,接受客户端发来请求
 5037：adb server 与adb client通讯的端口
 7555：mumu模拟器的端口

Capability设置：
 "platformName": "android",
  "deviceName": "127.0.0.1:7555",
  "appPackage": "com.xueqiu.android",
  "appActivity": ".view.WelcomeActivityAlias",
  "noReset": True #测试前后是否重置相关测试环境
  "unicodeKeyboard":False  #启用 Unicode 输入，默认 false
  "resetKeyboard":True 键盘重置为其原始状态 true 或者 false

Capability进阶：
newCommandTimeout: 隐式等待超时时间，默认是60s
udid：设备的唯一标识，未设置udid时默认取devices列表的第一个设备
autoGrantPermissions：授予弹框的权限，自动点击确认。默认false
noRest：测试前后是否重置相关测试环境 noreset=true
fullRest：清空数据并卸载app，使app保持干净环境
dontStopAppOnRest：首次启动的时候，不停止app（可以调试或者运行的时候提升运行速度）
skipDeviceInitialization  跳过安装，权限设置等操作（可以调试或者运行的时候提升运行速度）


Android七大布局：
线性布局：LinearLayout
相对布局:RelativeLayout
帧布局：FrameLayout
绝对布局:AbsoluteLayout
表布局:TableLayout
网格布局：GridLayout
约束布局：ConstrainLayout

四大组件：
activity：与用户交互的可视化的界面
service：实现程序后台运行的解决方案
content provider：内容提供者，提供程序所需要的数据
broadcast receiver：广播接收器,监听外部事件的到来

常用控件：
TextView:文本控件    EditText：可编辑文本控件
Button：按钮  ImageButton：图片按钮  ToggleButton：开关按钮
imageView：图片控件
Checkbox：复选框控件   RadioButton：单选框控件

测试步骤三要素：定位、交互、断言
定位方式：id(优先级最高),accessibility_id(其次),xpath(速度慢定位灵活)、uiautomator定位(速度快语法复杂)
id:resource-id
accessibility_id:content-desc

uiautomator定位：
基本语法：driver.find_element_by_android_uiautomator(xx)
1.通过text文本定位语法:
    new UiSelector().text("text文本")
2.如果文本比较长，可以用textContains模糊匹配:
    new UiSelector().textContains("包含text文本")
3.textStartsWith是以某个文本开头来匹配:
    new UiSelector().textStartsWith("以text文本开头")
4.正则表达式textMatches匹配：
    new UiSelector().textMatches("正则表达式")
5.resourceId定位：new UiSelector().resourceId("id")
6.className定位：new UiSelector().className("className")
7.description定位：new UiSelector().description("contenet-des属性")
8.组合定位：
  id与text属性组合：'new UiSelector().resourceId("com.baidu.yuedu:id/webbooktitle").text("小说")'
  class与text属性组合：'new UiSelector().className("android.widget.TextView").text("图书")'
9.关系定位：
 父子定位childSelector：'new UiSelector().resourceId("com.baidu.yuedu:id/rl_tabs").childSelector(text("小说"))'
 兄弟定位fromParent： 'new UiSelector().resourceId("com.baidu.yuedu:id/lefttitle").fromParent(text("图书"))'
10.滚动查找元素定位：new UiScrollable(new UiSelector().scrollable(true).instance(0)).
scrollIntoView(new UiSelector().text("李一恩的投资组合").instance(0))

uiautomatoreviewer工具(only andriod)

TouchAction：
press:按下
release：释放
movuTo:移动
tap：点
wait：等待
longpress：长按
cancel：取消
perform：执行
MultiTouch: 多点触摸

等待：
隐示等待：implicitly_wait   #放入setup方法中
显示等待：处理隐示等待无法解决的一些问题
WebDriverWait(self.driver,10).until(expected_conditions.element_to_be_clickable(locator)) #查找元素使用

toast控件识别：简易的消息提示框
必须使用xpath查找 ：
//*[@class='andriod.widget.Toast']
//*[@contains(@text,'xxxx')]

断言：
普通断言：assert
Hamcrest断言：

app参数化用例:与pytest一致

WebView
域套接字：进程与进程之前的一种方式
客户端与服务器建立连接，需要有共同的套接字和相应的服务器端口
套接字会处于监控状态，监听客户端发来的请求
获取webview的进程
adb shell cat /proc/net/unix grep "webview"

























emulator：ERROR：This AVD's configuration is missing a kernel file! 解决方法：
原因是kernal file的名称不正确。
找到.android\avd\你的虚拟设备.avd下的config.ini。
查找image.sysdir.1属性。
我的值是system-images\android-28\google_apis_playstore\x86\。
system-images在sdk目录下。
然后顺着image.sysdir.1的路径，看看该路径下有没有对应的kernel-qemu。
如果没有把kernel-ranchu-64改成该文件名。


emulator: ERROR: x86 emulation currently requires hardware acceleration!
Please ensure Intel HAXM is properly installed and usable.
CPU acceleration status: HAX kernel module is not installed!
安装D:\android-sdk-windows\extras\intel\Hardware_Accelerated_Execution_Manager下的intelhaxm-android.exe文件