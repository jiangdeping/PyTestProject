__init__.py or __all__=[]  #指对外开放有哪些内容,  调用方式必须 from * import * 方式导入
python 3.3版本 以后不需要__init__.py 文件也可以直接调用
浮点数精度问题：Decimal("0.1")+Decimal("0.2")
导出依赖包：
pip install -r requirements.txt
pip free >requirements.txt
----------------pytest------------
<<<<<<< HEAD
相关包安装：
pip install  pytest                ---pytest框架
pip install  allure-pytest         ---生成allure报告
pip install  pytest-assume         ---断言失败不会停止
pip install  pymysql               ---mysql数据库连接
pip install  pytest-rerunfailures  ---失败重跑
pip install   xlrd                 ---读取excel文件
pip install pytest-xdist           ---并行与分布式执行
pip install pytest-html            ---测试报告
pip install PyYAML                 ---yaml安装
pip install allure-pytest          ---测试allure-pytest插件
pip install pytest-ordering        ---测试用例顺序执行
=======
>>>>>>> parent of e736816 (2021/8/25:fix)
终端执行
pytest -v -s  文件名.py （-v 打印详细运行日志信息  -s带控制台输出结果）
pytest 文件名.py::类名 运行摸个模块里面的某个类
pytest 文件名.py::类名::方法名 运行某个模块里面的某个类里面的方法
pytest -m[标记名] @python.mark.[标记名] 将运行有这个标记的测试用例
pytest -x 文件名 运行到报错就停止
pytest --maxfail=[num] 当运行错误达到num的时候停止运行

pytest运行规则：
pytest 收集所有以 test_*.py(可在pytest.ini修改)开头的文件，类及函数和方法，都能识别成测试用例
常用参数
-k:满足表达式的都会执行
--collect-only 收集所有测试用例 不执行
-m 加标签，执行需要加个 -m参数，为用例@pytest.mark 标签名
-junit-xml 生产一个执行结果的xml文件

conftest.py文件:将需要共享的公共模块放在该文件，该文件放在不同的位置起着不同的范围共享作用，
不需要导入该文件，系统执行到参数时首先先从本文件中查找，然后在conftest.py中查找
改写一些方法，改写执行顺序
改写方法，自动添加标签
配置注意事项：
conftest.py文件名是不能更换的，与运行的用例放在同一package下

pytest.ini 配置文件
改变pytest运行的行为
“”“
[pytest]
addopts=--alluredir=./result/1
python_files="abc_*py"
python_classes="Login*"
python_functions="case*"
“”“

pytest失败重新运行：
pip install pytest-rerunfailures
pytest --reruns 3  --reruns-delay 2  -v -s 文件名.py  #--reruns 3 重新执行的次数 --reruns-delay 2 等待2s执行
运行时间：07-07-51:00

pytest 多条断言有失败也都运行
pip install pytest-assume
pytest.assume(表达式)

pycharm 配置与执行pytest测试框架
pytest.main("-v -x TestDemo") 、pytest.main(['-v','-s','TestDemo'])等同

pytest框架结构:
pytest的setup、teardown更灵活，执行顺序：
模块级(setup_module/teardown_module)模块始末，全局的(优先更高)
函数级(setup_function/teardown_function)只对函数用例生效(不在类中)
类级(setup_class/teardown_class)只在类中前后运行一次(在类中)
方法级(setup_method/teardown_method)开始于方法始末(在类中)
类里面的(setup/teardown)运行在调用方法的前后

pytest-fixture:
有些用例需要登录，有些不需要登录。setup和teardown无法满足，fixture可以
在登录的函数面前加入@pytest.fixture,在需要登录的测试方法中传入登录函数名称

yield 生成器， 相当于:return i+暂停+并记住上一次运行位置,与fixture结合使用，激活yield后面的操作
yield：通过在方法中加入yield关键字，yield之前的第一次调用该方法时执行，yield之前的后在最后一次调用该方法时执行
@pytest.fixture(scope=module)
scope:session 作用域、function 方法 、class 类 、module 模块、package包
执行顺序：session>module>function,如果有antouse=True,优先于同等级


fixture的自动化应用：
在方法上加 @pytest.fixture(autouse=True)，每一条测试用例都加上该方法
在测试方法上加 @pytest.mark.usefixtures("start")

fixture带参数传递
@pytest.fixture(params=[1,2,3,'linda']),在方法参数前写request



mark中的skip与xfail
skip：不想运行某些测试用例，skipif 满足条件的不运行该用例
xfail：标记用例预期失败，如果用例运行成功则显示Xpassed，失败则显示xfailed。
xfail标记并不会影响用例的运行。设置strict=True以确保XPASS时，测试的记录为失败

pytest并行与分布式执行：
pytest  文件名.py -n number

pytest-html:生成报告
pytest -v -s --html=report.html--self-contained-html

pytest数据参数化
@pytest.mark.parametrize(argnames,argvalues)  argnames,argvalues一一对应
argnames:要参数化的变量,string,list,tuple
argvalues:参数化的值,list,list[tuple]

yaml实现list
pip install PyYAML
yaml.safe_load(open("文件名.yaml"))

数据驱动：app、web、接口自动化测试
测试步骤的数据驱动、测试数据的数据驱动、配置的数据驱动

allure:
安装：
1.安装jdk1.8+(百度网盘)
2.安装Allure(百度网盘)
  解压并进入bin目录，运行allure.bat，将bin路径添加allure到环境变量PATH
3.安装allure—pytest插件
步骤：
1.测试执行期间收集执行结果
pytest 文件名.py  --alluredir=./result/1 (--alluredir 指定存储测试结果的路径)
2.生成测试报告
 方法1：测试完成后查看实际报告 allure serve ./result/5
 方法2：从结果生成报告
      生成报告：allure generate ./result/ -O ./report --clean(覆盖路径加--clean)
      查看报告：allure open -h 127.0.0.1 -p 8883 ./report/

常用特性
@allure.feature("功能名称")
@allure.story("子功能名称")
with.allure.step("步骤细节")
@allure.attach("具体文本信息"，需要附近的信息可以是数据、文本、图片、视频、网页)
只运行部分功能：pytest 文件名  --allure_features "功能名称"  --allure_stories "子功能名称"

按重要级别进行的范围测试
1.附加pytest.mark标记
2.allure.feature,allure.story
3.allure.severity附加标记   级别：Trivial不重要、Minor不太重要、Normal正常、Critical严重、Blocker阻塞
步骤：
在方法、函数和类前面加：@allure.severity(allure.severity_level.级别)
执行时：pytest -s -v 文件名 --allure-severities 级别(可多个用’,‘分割)

驱动:
测试数据的驱动
测试步骤的驱动



---------------selenium----------------
chromedriver下载地址：http://npm.taobao.org/mirrors/chromedriver
webdriver
IDE：录制
Grid：分布式
等待,直到显示：WebDriverWait(self.driver,10).until(expected_conditions.element_to_be_clickable(()))

XPATH:XML Path Language(速度比较慢)
/从根节点选取   //从匹配选择的当前节点选择文档中的节点，不考虑他们的位置
. 选择当前节点   ..选择当前节点的父节点  @选取属性
/bookstore/book[1]      选取属于bookstore子元素的第一个book元素
/bookstore/book[last()]  选取属于bookstore子元素的最后一个book元素
/bookstore/book[last()-1] 选取属于bookstore子元素的倒数第二book元素
/bookstore/book[position()<3]  选取最前面的2个属于bookstore元素的子元素的book元素
//title[@lang="eng"]  选取所有title元素，这些元素拥有值为eng的lang属性
/bookstore/book[price>10] 选取bookstore的所有book元素，且price>10
/bookstore/book[price>10]/title 选取bookstore的所有book元素的所有title元素，且price>10

CSS Selector定位:
浏览器操作：$('#su')
# 表示id
. 表示class
> 表示子元素，层级


ActionChains：执行PC端的鼠标点击、双击、右键、拖拽等事件
TouchActions：模拟PC和移动端的点击、滑动、拖拽、多点触控等多种手势操作
当用户调用ActionChains方法执行动作时，这些动作会被存储到一个ActionChains对象的队列中，此时并不会真
正执行这些动作。而当调用perform()时，ActionChains对象中动作队列会被一一执行
action.drag_and_drop(drag_element,drop_element).perform() #拖拽方法1
action.click_and_hold(drag_element).release(drop_element).perform()#拖拽方法2


selenium 如何处理多窗口：
点击某些链接，会重新打开一个窗口，对于这种情况，想在新页面操作就需要切换窗口了
获取窗口唯一标识用句柄表示，所以只需要切换句柄，就可以在多个页面灵活操作
获取当前窗口的句柄：driver.current_window_handle
获取到所有的窗口句柄：driver.window_handles
切换窗口：switch_to_window

frame：一个元素定位不到，很大可能该元素不再iframe中
frame分类：frameset、frame、iframe
driver.switch_to.frame()：根据元素ID或index切换frame
driver.switch_to.default_content() 切换到默认frame
driver.switch_to.parent_frame 切换到父级frame
对于签到的iframe：先切换到父节点在切换到子节点

selenium执行javascript脚本，解决:
1.直接使用JS操作页面，解决很多click()不生效的问题
2.页面滚动到底部，顶部
3.处理富文本，时间控件输入等
execute_script：执行js
return:返回js的返回结果
execute_script：arguments传参
JS处理时间控件思路：
1.取消日期的readonly属性 :
a=document.getElementById("train_date")
a.removeAttribute('readonly')
2.给value赋值
3.写js代码实现如上2点，在用webdriver对js进行处理

selenium文件上传：input标签可以直接使用send_keys(文件地址)上传文件

弹框处理机制：
在页面操作中会遇到JavaScript生产的alert、confirm及prompt弹框，可以使用switch_to.alert()方法定位。
然后使用text/accept/dismiss/send_keys等方法进行操作
操作alert常用方法：
switch_to.alert():获取当前页面的警告框
text:返回alert、confirm及prompt中的文字信息
accept():接受现有警告框
dismiss():解散现有警告框
send_keys(keysToSend):发送文件警告框。keysToSend：将文本发送至警告框
#snipaste  截图工具

page Objects 六大原则：
1.公共方法表示页面提供的服务
2.不要暴露页面的细节
3.Page设计中不要出现断言，应该写在测试用例类中
4.方法应该返回其他的Page对象
5.不要去代表整个page，如果一个页面中有很多功能，只需要对重点功能封装方法即可
6.不同的结果返回不同的方法，不同的模式

selenium复用浏览器
1.chrome浏览器放入环境变量
2.在命令下执行:chrome --remote-debugging-port=9222
3.options=Options()
  options.debugger_address="127.0.0.1:9222"
  driver=webdriver.Chrome(options=options)


appnium安装环境搭建：https://www.cnblogs.com/fnng/p/4540731.htmlhttps://www.cnblogs.com/fnng/p/4540731.html
1.JDK 1.8及以上版本安装
2.SDK安装及环境变量配置 ：http://tools.android-studio.org/index.php/sdk
   ANDROID_HOME D:\android-sdk-windows
   PATH  %ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools
   查看安装成功  adb
3.appium环境安装及客户端安装：
  方法一：下载安装包安装：https://github.com/appium/appium-desktop/releases
  方法二：npm安装:   需要先装 node.js
     npm install -g cnpm --registry==https://registry.npm.taobao.org
     cnpm install -g appium
4.安装appnium-client：pip install appium-python-client
5.安装appium-doctor:npm install appium-doctor  查看appium安装信息
6.安装网易mumu模拟器：https://mumu.163.com/
 无法连接网易mumu：D:\MuMu\emulator\nemu\vmonitor\bin下执行：adb connect 127.0.0.1:7555
 使用教程：https://www.pianshen.com/article/27411242829/

Capability设置：
 "platformName": "android",
  "deviceName": "127.0.0.1:7555",
  "appPackage": "com.xueqiu.android",
  "appActivity": ".view.WelcomeActivityAlias",
  "noReset": True #测试前后是否重置相关测试环境
  "unicodeKeyboard":False  #启用 Unicode 输入，默认 false
  "resetKeyboard":True 键盘重置为其原始状态 true 或者 false